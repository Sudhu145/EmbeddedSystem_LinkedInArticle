/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

static void gccInlineAssemblyExample1(void)
{
	/* R0,R1...,R12 are general purpose register, a part of the core register of arm cortex-m family
	 * Each register consist of 32 bits*/

	/* Load R0 with direct value of 0x20002000 */
	__asm volatile ("LDR R0,=#0x20002000");

	/* Load R1 with direct value of 0x20002004 */
	__asm volatile ("LDR R1,=#0x20002004");

	/* Load R2 with direct value of 0x01 */
	__asm volatile ("LDR R2, =#0x01");

	/* Load R3 with direct value of 0x02 */
	__asm volatile ("LDR R3, =#0X02");

	/* Store the value of R2 into the memory address stored in R0 */
	__asm volatile ("STR R2, [R0]");

	/* Store the value of R3 into the memory address stored in R1 */
	__asm volatile ("STR R3, [R1]");

	/* Load the value from the memory address stored in the R0 into R4 */
	__asm volatile ("LDR R4, [R0]");

	/* Load the value from the memory address stored in the R1 into R5 */
	__asm volatile ("LDR R5, [R1]");

	/* ADD the values stored in R4 and R5, and store in the R6 */
	__asm volatile ("ADD R6, R4, R5");

	/* Store the value of R6, into the memory address stored in R0 */
	__asm volatile ("STR R6, [R0]");
}


static void gccInlineAssemblyExample2(void)
{
	/* Writing multiple instruction within the same __asm statement */

	/* R0,R1...,R12 are general purpose register, a part of the core register of arm cortex-m family
	 * Each register consist of 32 bits*/

	__asm volatile ("LDR R0,=#0x20002008\n\t"	/* Load R0 with direct value of 0x20002008 */
					"LDR R1,=#0x2000200C\n\t"	/* Load R1 with direct value of 0x2000200C */
					"LDR R2, =#0x01\n\t"		/* Load R2 with direct value of 0x01 */
					"LDR R3, =#0X02\n\t"		/* Load R3 with direct value of 0x02 */
					"STR R2, [R0]\n\t"			/* Store the value of R2 into the memory address stored in R0 */
					"STR R3, [R1]\n\t"			/* Store the value of R3 into the memory address stored in R1 */
					"LDR R4, [R0]\n\t"			/* Load the value from the memory address stored in the R0 into R4 */
					"LDR R5, [R1]\n\t"			/* Load the value from the memory address stored in the R1 into R5 */
					"ADD R6, R4, R5\n\t"		/* ADD the values stored in R4 and R5, and store in the R6 */
					"STR R6, [R0]\n\t"			/* Store the value of R6, into the memory address stored in R0 */
	);

}

/*** Get ISPR register value ***/
static uint32_t __get_IPSR(void)
{
	/* Local variables */
	uint32_t ipsr_value;

	/* Get the value of IPSR */
	/*
	* __asm volatile: This is a GCC compiler extension that allows inline assembly code to be included in the C or C++ source code.
	* The volatile keyword ensures that the compiler does not optimize or reorder the assembly instructions.
	*
	* "MRS %0, xPSR\n": This is the assembly instruction itself. It is written as a string literal and represents the ARM assembly instruction "MRS" (Move to Register from Special register).
	* The %0 is a placeholder for the first output operand.
	*
	* : "=r" (ipsr_value): This part is called the output operand specification. It indicates the operand that will hold the value read from the xPSR register.
	* The = sign denotes that it is an output operand, and "r" specifies that it should be allocated a general-purpose register.
	*/
	__asm volatile (
		"MRS %0, xPSR\n"
		: "=r" (ipsr_value)
	);

	/* Extract the IPSR bits[8:0] */
	ipsr_value = (ipsr_value & 0x1FF);

	/* Return IPSR value */
	return ipsr_value;
}

int main(void)
{
	/*** Example: 1 - GCC inline assembly statement without operand  ***/
	gccInlineAssemblyExample1();

	/*** Example: 2 - GCC inline assembly statement without operand  ***/
	gccInlineAssemblyExample2();

	/*** Example: 3 - Move the contents of C variable value to ARM register R0 ***/
	uint32_t val1 = 0x11223344;
	__asm volatile ("MOV R0,%0"::"r"(val1));

	/*** Example: 4 - Move the contents of C variable value to ARM register R1, also having clobber list which tells complier
	 * to prevent from using a register {r1} for a template string in an inline assembly string, add the register to the clobber list. ***/
	uint32_t val2 = 0x55667788;
	__asm volatile ("MOV R1,%0"::"r"(val2):"r1");

	/*** Example 5 - Move the contents of CONTROL register to C variable ***/
	uint32_t regVal;
	__asm volatile ("MRS %0,CONTROL":"=r"(regVal));

	/*** Example 6 - Copy the content of C variable, variable 1 to variable 2 ***/
	uint32_t var1=0x10,var2;
	__asm volatile ("MOV %0,%1":"=r"(var2):"r"(var1));

	/*** Example 7 - Copy the contents of a pointer into another variable ***/
	uint32_t var, *ptr=((uint32_t*)0x20003000);
	*ptr = 0x20;
	__asm volatile ("LDR %0,[%1]":"=r"(var):"r"(ptr));

	/*** Example 8 - Get ISPR register value ***/
	__get_IPSR();

    /* Loop forever */
	for(;;);
}
